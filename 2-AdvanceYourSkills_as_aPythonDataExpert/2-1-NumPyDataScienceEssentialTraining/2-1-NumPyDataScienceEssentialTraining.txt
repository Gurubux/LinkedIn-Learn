NumPy Data Science Essential Training
INTRODUCTION
WELCOME (VIEWED)
WHAT YOU SHOULD KNOW (VIEWED)
NUMPY, DATA SCIENCE, IMQAV (VIEWED)
HOW TO USE THE EXERCISE FILES
INSTAL SOFTWARE

1. NOTEBOOKS
INTRODUCTION TO JUPYTER NOTEBOOK
NOTEBOOK BASICS
MARKDOWN
BEAUTIFUL MATHEMATICS TYPESETTING
LAUNCH JUPYTER NOTEBOOK

2. CREATE NUMPY ARRAYS
CREATE ARRAYS FROM PYTHON STRUCTURES
INTRINSIC CREATION USING NUMPY METHODS
LINSPACE, ZEROS, ONES, DATA TYPES

3. INDEX, SLICE, AND ITERATE
SLICE ARRAYS
BOOLEAN MASK ARRAYS
BROADCASTING
STRUCTURED AND RECORD ARRAYS

4. PLOTS: MATPLOTLIB AND PYPLOT
INLINE PLOTTING
FIGURES AND SUBPLOTS
MULTIPLE LINES, SINGLE PLOT
TICK MARKS, LABELS, AND GRIDS
PLOT ANNOTATIONS
PIE CHARTS AND BAR CHARTS
BEAUTIFUL PLOTS, THE GALLERY

5. MANIPULATE ARRAYS
VIEWS AND COPIES
ARRAY ATTRIBUTES
ADD AND REMOVE ELEMENTS
JOIN AND SPLIT ARRAYS
ARRAY SHAPE MANIPULATION
REARRANGE ARRAY ELEMENTS
TRANSPOSE LIKE OPERATIONS
TILING ARRAYS

6. SHORT EXAMPLES
UNIVERSAL FUNCTIONS
PYTHAGOREAN TRIANGLES
LINEAR ALGEBRA
FINDING PATTERNS
STATISTICS
BRAIN TEASERS

7. EXTENDED EXAMPLES
MAGIC SQUARES AND NUMPY
ADJACENCY MATRIX
MAGIC CHARACTERISTICS
BUILD MAGIC CUBES



************************************************************************************************************
INTRODUCTION
WELCOME 
WHAT YOU SHOULD KNOW 
NUMPY, DATA SCIENCE, IMQAV 
 IMQAV
	Ingest
	Model
	Query
	Analyze - NumPy
	Visualize

HOW TO USE THE EXERCISE FILES
INSTAL SOFTWARE

************************************************************************************************************
1. NOTEBOOKS
************************************************************************************************************
INTRODUCTION TO JUPYTER NOTEBOOK
NOTEBOOK BASICS
MARKDOWN
Light-weight markup language
BEAUTIFUL MATHEMATICS TYPESETTING
LAUNCH JUPYTER NOTEBOOK
QUIZ
- Jupyter uses TeX to format mathematics.  https://en.wikipedia.org/wiki/TeX
- A Jupyter notebook can contain interactive cells and markdown cells.


************************************************************************************************************
2. CREATE NUMPY ARRAYS
************************************************************************************************************
---------------------------------------------------------------
CREATE ARRAYS FROM PYTHON STRUCTURES
my_list = [-17, 0, 4, 5, 9]
my_array_from_list = np.array(my_list)

my_tuple = (14, -3.54, 5+7j)
np.array(my_tuple)
 Difference between python and numpy data structures
 my_tuple * 6
 	>>>
 		(14,
 		-3.54,
 		(5+7j),
 		14,
 		-3.54,
 		(5+7j),
 		14,
 		-3.54,
 		(5+7j),
 		14,
 		-3.54,
 		(5+7j),
 		14,
 		-3.54,
 		(5+7j),
 		14,
 		-3.54,
 		(5+7j))

 np.array(my_tuple) * 6 
 	>>> array([ 84.   +0.j, -21.24 +0.j,  30.  +42.j])


---------------------------------------------------------------
INTRINSIC CREATION USING NUMPY METHODS
np.arange(10, 23)
np.arange(10, 23) -10 +1
len (np.arange(10, 23))
np.arange(10, 23).size
np.arange(10, 23, 5)
np.arange(26, step=5)


---------------------------------------------------------------
LINSPACE, ZEROS, ONES, DATA TYPES
np.linspace(5, 15, 9)

#Return the step size 
my_linspace = np.linspace(5, 15, 9, retstep=True)
my_linspace[1]


np.zeros(5)
>>> array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros(11, dtype='int64')
>>> array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

np.ones(7)

np.zeros((5,4))
>>>	array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])

np.zeros((5,4,3))
>>>	array([[[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]],

       [[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]],

       [[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]],

       [[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]],

       [[ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.],
        [ 0.,  0.,  0.]]])


---------------------------------------------------------------
QUIZ
************************************************************************************************************
3. INDEX, SLICE, AND ITERATE
************************************************************************************************************
SLICE ARRAYS

my_array[5,2] # 6th row 3rd column

my_3D_array[1,3,2] # 2nd 2d array, 4th row, 3rd column


---------------------------------------------------------------
BOOLEAN MASK ARRAYS

my_vector = np.array([-17, -4, 0, 2, 21, 37, 105])
zero_mod_7_mask = 0 == (my_vector % 7)
>>> array([False, False,  True, False,  True, False,  True], dtype=bool)

sub_array = my_vector[zero_mod_7_mask]
>>> array([  0,  21, 105])

sub_array[sub_array>0]
>>> array([ 21, 105])


mod_test = 0 == (my_vector % 7)
>>> array([False, False,  True, False,  True, False,  True])

positive_test = my_vector > 0
>>> array([False, False, False,  True,  True,  True,  True])

combined_mask = np.logical_and(mod_test, positive_test)
array([False, False, False, False,  True, False,  True])
---------------------------------------------------------------
BROADCASTING
Broadcasting describes how NumPy performs operations between arrays with different sizes. NumPy requires that arrays be compatible before broadcasting can take place. 

my_3D_array = np.arange(70)
my_3D_array.shape = (2,7,5)
array([[[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24],
        [25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34]],

       [[35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44],
        [45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54],
        [55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64],
        [65, 66, 67, 68, 69]]])

# shape
my_3D_array.shape
(2, 7, 5)
# number of dimensions
my_3D_array.ndim
3

# size; number of elements
len(my_3D_array)
2
my_3D_array.size
70

# data type for each element
my_3D_array.dtype
dtype('int32')


5 * my_3D_array - 2


left_mat = np.arange(6).reshape((2,3))
right_mat = np.arange(15).reshape((3,5))

np.inner(left_mat, right_mat)
>>> ValueError: shapes (2,3) and (3,5) not aligned: 3 (dim 1) != 5 (dim 1)


np.dot(left_mat, right_mat)
array([[ 25,  28,  31,  34,  37],
       [ 70,  82,  94, 106, 118]])

my_3D_array
array([[[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24],
        [25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34]],

       [[35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44],
        [45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54],
        [55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64],
        [65, 66, 67, 68, 69]]])
(2, 7, 5)

my_3D_array.sum()
2415

my_3D_array.sum(axis=0)
array([[ 35,  37,  39,  41,  43],
       [ 45,  47,  49,  51,  53],
       [ 55,  57,  59,  61,  63],
       [ 65,  67,  69,  71,  73],
       [ 75,  77,  79,  81,  83],
       [ 85,  87,  89,  91,  93],
       [ 95,  97,  99, 101, 103]])


my_3D_array.sum(axis=1)
array([[105, 112, 119, 126, 133],
       [350, 357, 364, 371, 378]])

my_3D_array.sum(axis=2)
array([[ 10,  35,  60,  85, 110, 135, 160],
       [185, 210, 235, 260, 285, 310, 335]])


Broadcasting Rules
my_random_2D_array = np.random.random((7,5))
>>> array([[0.90367789, 0.87967533, 0.17337795, 0.60741536, 0.4864643 ],
       [0.94829643, 0.04550254, 0.20781481, 0.22725033, 0.73219964],
       [0.22239651, 0.94486922, 0.04705222, 0.08097157, 0.29670037],
       [0.29239383, 0.39246099, 0.2671365 , 0.64610526, 0.53935041],
       [0.50347683, 0.07003444, 0.85674922, 0.25853368, 0.4836854 ],
       [0.74194028, 0.02943969, 0.67612621, 0.06892332, 0.17147297],
       [0.09527089, 0.52649234, 0.10152999, 0.17389911, 0.73905488]])

np.set_printoptions(precision=4)
my_3D_array * my_random_2D_array
array([[[ 0.    ,  0.8797,  0.3468,  1.8222,  1.9459],
        [ 4.7415,  0.273 ,  1.4547,  1.818 ,  6.5898],
        [ 2.224 , 10.3936,  0.5646,  1.0526,  4.1538],
        [ 4.3859,  6.2794,  4.5413, 11.6299, 10.2477],
        [10.0695,  1.4707, 18.8485,  5.9463, 11.6084],
        [18.5485,  0.7654, 18.2554,  1.9299,  4.9727],
        [ 2.8581, 16.3213,  3.249 ,  5.7387, 25.1279]],

       [[31.6287, 31.6683,  6.415 , 23.0818, 18.9721],
        [37.9319,  1.8656,  8.7282,  9.7718, 32.2168],
        [10.0078, 43.464 ,  2.2115,  3.8866, 14.5383],
        [14.6197, 20.0155, 13.8911, 34.2436, 29.1249],
        [27.6912,  3.9219, 48.8347, 14.995 , 28.5374],
        [44.5164,  1.7958, 41.9198,  4.3422, 10.9743],
        [ 6.1926, 34.7485,  6.8025, 11.8251, 50.9948]]])


np.dot(my_3D_array,my_random_2D_array.reshape(5,7))
array([[[  1.287 ,   4.0682,   2.6738,   4.3137,   4.869 ,   1.9097,6.0725],
        [  9.0228,  16.2059,  10.933 ,  14.8493,  19.4736,  10.5999,16.2982],
        [ 16.7585,  28.3436,  19.1922,  25.385 ,  34.0781,  19.29  ,26.5238],
        [ 24.4943,  40.4813,  27.4515,  35.9206,  48.6827,  27.9802,36.7495],
        [ 32.23  ,  52.619 ,  35.7107,  46.4562,  63.2872,  36.6704,46.9752],
        [ 39.9658,  64.7567,  43.9699,  56.9918,  77.8917,  45.3606,57.2008],
        [ 47.7015,  76.8944,  52.2291,  67.5275,  92.4963,  54.0508,67.4265]],

       [[ 55.4373,  89.0321,  60.4883,  78.0631, 107.1008,  62.741 ,77.6521],
        [ 63.173 , 101.1698,  68.7475,  88.5987, 121.7054,  71.4312,87.8778],
        [ 70.9088, 113.3076,  77.0067,  99.1344, 136.3099,  80.1214,98.1035],
        [ 78.6446, 125.4453,  85.266 , 109.67  , 150.9145,  88.8116,108.3291],
        [ 86.3803, 137.583 ,  93.5252, 120.2056, 165.519 ,  97.5018,118.5548],
        [ 94.1161, 149.7207, 101.7844, 130.7413, 180.1236, 106.1919,128.7804],
        [101.8518, 161.8584, 110.0436, 141.2769, 194.7281, 114.8821,139.0061]]])

my_vector = np.arange(5) * 7
my_vector[0] = -1
array([-1,  7, 14, 21, 28])

my_3D_array
array([[[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24],
        [25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34]],

       [[35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44],
        [45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54],
        [55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64],
        [65, 66, 67, 68, 69]]])
my_3D_array / my_vector

array([[[ -0.    ,   0.1429,   0.1429,   0.1429,   0.1429],
        [ -5.    ,   0.8571,   0.5   ,   0.381 ,   0.3214],
        [-10.    ,   1.5714,   0.8571,   0.619 ,   0.5   ],
        [-15.    ,   2.2857,   1.2143,   0.8571,   0.6786],
        [-20.    ,   3.    ,   1.5714,   1.0952,   0.8571],
        [-25.    ,   3.7143,   1.9286,   1.3333,   1.0357],
        [-30.    ,   4.4286,   2.2857,   1.5714,   1.2143]],

       [[-35.    ,   5.1429,   2.6429,   1.8095,   1.3929],
        [-40.    ,   5.8571,   3.    ,   2.0476,   1.5714],
        [-45.    ,   6.5714,   3.3571,   2.2857,   1.75  ],
        [-50.    ,   7.2857,   3.7143,   2.5238,   1.9286],
        [-55.    ,   8.    ,   4.0714,   2.7619,   2.1071],
        [-60.    ,   8.7143,   4.4286,   3.    ,   2.2857],
        [-65.    ,   9.4286,   4.7857,   3.2381,   2.4643]]])
my_3D_array % my_vector
array([[[ 0,  1,  2,  3,  4],
        [ 0,  6,  7,  8,  9],
        [ 0,  4, 12, 13, 14],
        [ 0,  2,  3, 18, 19],
        [ 0,  0,  8,  2, 24],
        [ 0,  5, 13,  7,  1],
        [ 0,  3,  4, 12,  6]],

       [[ 0,  1,  9, 17, 11],
        [ 0,  6,  0,  1, 16],
        [ 0,  4,  5,  6, 21],
        [ 0,  2, 10, 11, 26],
        [ 0,  0,  1, 16,  3],
        [ 0,  5,  6,  0,  8],
        [ 0,  3, 11,  5, 13]]], dtype=int32)
---------------------------------------------------------------
STRUCTURED AND RECORD ARRAYS
# Structured Arrays are datatypes that can be used to create numpy arrays, You can pass  ('key','datatype') pair as in the below example
person_data_def = [('name','S6'),('height','f8'),('weight','f8'), ('age', 'i8')] 
>>> [('name', 'S6'), ('height', 'f8'), ('weight', 'f8'), ('age', 'i8')]

people_array = np.zeros((4,), dtype=person_data_def)
>>> array([('', 0.0, 0.0, 0), ('', 0.0, 0.0, 0), ('', 0.0, 0.0, 0),
       ('', 0.0, 0.0, 0)], 
      dtype=[('name', 'S6'), ('height', '<f8'), ('weight', '<f8'), ('age', '<i8')])


RECORD ARRAYS are similar but normal arrays are enclosed with rec.array making it an even easiers access to the keys eg. person_record_array[0].age

person_record_array = np.rec.array([('Delta', 73, 205, 34),('Alpha', 65, 112, 23)],dtype=person_data_def)
>>> rec.array([('Delta', 73.0, 205.0, 34), ('Alpha', 65.0, 112.0, 23)], 
          dtype=[('name', 'S6'), ('height', '<f8'), ('weight', '<f8'), ('age', '<i8')])

person_record_array[0].age

QUIZ
1. You can use this data source to create a NumPy array.
	scalars
	dictionaries
	lists
2.You can use this function to create a NumPy arrays.
	linspace() and zeros()
3.	NumPy indices begin with 0.
4.How many arguments (parameters) can a NumPy index have?
	zero, one, or two
5. A Boolean mask DOES NOT erase information in a NumPy array.
6. Broadcasting transfers a NumPy array across a network.
7. Structured arrays have varying length elements. - False

************************************************************************************************************
4. PLOTS: MATPLOTLIB AND PYPLOT
************************************************************************************************************
INLINE PLOTTING
%matplotlib inline #Magic directive
# the histogram of the data
n, bins, patches = plt.hist(data_set, 50, density=True, facecolor='g', alpha=0.75)

plt.xlabel('Smarts')
plt.ylabel('Probability')
plt.title('Histogram of IQ')
plt.text(60, .025, r'$\mu=100,\ \sigma=15$')
plt.axis([40, 160, 0, 0.03])
plt.grid(True)
plt.show()
Available Colors:

code       color
________________________
'k'         black
'b'         blue
'c'         cyan
'g'         green
'm'         magenta
'r'         red
'w'         white
'y'         yellow
Available Markers:

marker	description
”.”				point
”,”				pixel
“o”				circle
“v”				triangle_down
“^”				triangle_up
“<”				triangle_left
“>”				triangle_right
“1”				tri_down
“2”				tri_up
“3”				tri_left
“4”				tri_right
“8”				octagon
“s”				square
“p”				pentagon
“*”				star
“h”				hexagon1
“H”				hexagon2
“+”				plus
“x”				x
“D”				diamond
“d”				thin_diamond
“|”				vline
“_”				hline
TICKLEFT		tickleft
TICKRIGHT		tickright
TICKUP			tickup
TICKDOWN		tickdown
CARETLEFT		caretleft
CARETRIGHT		caretright
CARETUP			caretup
CARETDOWN		caretdown
“None”			nothing
None			nothing
” “				nothing
“”				nothing
'$...$'			render the string using mathtext.
verts			a list of (x, y) pairs used for Path vertices. The center of the marker is located at (0,0) and the size is normalized.
path			a Path instance.
(numsides, style, angle)	see below

---------------------------------------------------------------
FIGURES AND SUBPLOTS
my_first_figure = plt.figure("My First Figure")

subplot_1 = my_first_figure.add_subplot(2, 3, 1)
subplot_6 = my_first_figure.add_subplot(2, 3, 6)

plt.plot(np.random.rand(50).cumsum(), 'k--') # k = black and -- marker

subplot_2 = my_first_figure.add_subplot(2, 3, 2)
plt.plot(np.random.rand(50), 'go') # green and o marker
---------------------------------------------------------------
MULTIPLE LINES, SINGLE PLOT

plt.plot(days, low_data_set, # draw lines
         days, low_data_set, "vm", # draws down triangle marker on each data point
         days, high_data_set, # draw lines
         days, high_data_set, "^k") # up triangle marker
plt.show()

plt.legend((l2, l4), ('oscillatory', 'damped'), loc='upper right', shadow=True)

---------------------------------------------------------------
TICK MARKS, LABELS, AND GRIDS
labels = subplot_1.set_xticklabels(['one', 'two', 'three', 'four', 'five'], rotation=45, fontsize='small')
subplot_1.set_title ("My First Ticked Plot")
subplot_1.set_xlabel ("Groups")

subplot_1.grid(True)
gridlines = subplot_1.get_xgridlines() + subplot_1.get_ygridlines()
for line in gridlines:
    line.set_linestyle(':')
plt.show()

"""
Line styles for grid lines

- solid line
-- dashed line
-. dash dot line
: dotted
More information about lines available at: http://matplotlib.org/api/lines_api.html
"""
---------------------------------------------------------------
PLOT ANNOTATIONS
---------------------------------------------------------------
PIE CHARTS AND BAR CHARTS
In addition to a basic pie chart, this demo shows a few optional features:

* slice labels
* auto-labeling the percentage
* offsetting a slice with "explode"
* drop-shadow
* custom start angle
Note about the custom start angle:

The default startangle is 0, which would start the "Frogs" slice on the positive x-axis. This example sets startangle = 90 such that everything is rotated counter-clockwise by 90 degrees, and the frog slice starts on the positive y-axis.

PIE CHARTS
explode - to take a pie out of the Pie Chart 
shadow - To add some shadow effect


# The slices will be ordered and plotted counter-clockwise.
labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
sizes = [15, 30, 45, 10]
colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']
explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
plt.pie(x=sizes, explode=explode, labels=labels, colors=colors,
        autopct='%1.1f%%', shadow=True, startangle=90)
# Set aspect ratio to be equal so that pie is drawn as a circle.
plt.axis('equal')


BAR CHARTS



N = 5
menMeans = (20, 35, 30, 35, 27)
menStd = (2, 3, 4, 1, 2)

ind = np.arange(N)  # the x locations for the groups
width = 0.35       # the width of the bars

fig, ax = plt.subplots()
rects1 = ax.bar(ind, menMeans, width, color='r', yerr=menStd)

womenMeans = (25, 32, 34, 20, 25)
womenStd = (3, 5, 2, 3, 3)
rects2 = ax.bar(ind + width, womenMeans, width, color='y', yerr=womenStd)


# add some text for labels, title and axes ticks
ax.set_ylabel('Scores')
ax.set_title('Scores by group and gender')

ax.set_xticks(ind + width)
ax.set_xticklabels(('G1', 'G2', 'G3', 'G4', 'G5'))

ax.legend((rects1[0], rects2[0]), ('Men', 'Women'))


---------------------------------------------------------------
BEAUTIFUL PLOTS, THE GALLERY
QUIZ
************************************************************************************************************
5. MANIPULATE ARRAYS
************************************************************************************************************
VIEWS AND COPIES

mi_casa = np.array([-45, -31, -12, 0, 2, 25, 51, 99])
su_casa = mi_casa
#Change in each causes change in another
id(su_casa) == id(mi_casa) #True
su_casa == mi_casa #True


"Shallow Copy" - np_array.view()
tree_house = np.array([-45, -31, -12, 0, 2, 25, 51, 99])
farm_house = tree_house.view()
farm_house.shape = (2,4)

>>> array([214, -31, -12,   0,   2,  25,  51,  99])
>>> array([[214, -31, -12,   0],
      	   [  2,  25,  51,  99]])
id(farm_house) == id(tree_house) False
farm_house == tree_house  False

\BUT, changes made in 1 is affected in other
tree_house [3] = -111
farm_house
array([[ 214,  -31,  -12, -111],
       [   2,   25,   51,   99]])


"DEEP Copy" np.copy(np_array)
dog_house = np.copy(tree_house)
dog_house[0] = -121
dog_house
>>> array([-121,  -31,  -12, -111,    2,   25,   51,   99])
tree_house
>>> array([ 214,  -31,  -12, -111,    2,   25,   51,   99])

\Changes made in 1 is NOT affected in other

QUIZ
NumPy’s matrix data type is derived from NumPy’s array data type.
---------------------------------------------------------------
ARRAY ATTRIBUTES
---------------------------------------------------------------
ADD AND REMOVE ELEMENTS

b=np.append(a, [5,6,7,8])

b.reshape((7,4))

np.append(a,c, axis=0)

np.append(a,c, axis=1)

np.append(a,c, axis=2)

my_hay_stack = np.hstack((a,c))


after_insert_array = np.insert (c, 1, 444, axis=0) # 2dArray

np.insert (c, 1, 444, axis=1) # A row

np.insert (c, 1, 444, axis=2) # Column

d = np.empty(c.shape)
np.copyto(d, c) # copy c into d

np.delete(d, 1, axis=0)

np.delete(d, 1, axis=1)

np.delete(d, 1, axis=2)
---------------------------------------------------------------
JOIN AND SPLIT ARRAYS
concatenate
stack
split

1. concatenate
together = np.concatenate((a, b), axis=0) # row
together = np.concatenate((a, c), axis=1) # column

2. stack
Creating nd arrays
arrays = np.zeros((5,3,4))
for n in range(5):
    arrays[n] = np.random.randn(3, 4)

stack0 = np.stack(arrays, axis=0)
stack1 = np.stack(arrays, axis=1)
stack2 = np.stack(arrays, axis=2)
my_stacks = np.array([stack0.shape, stack1.shape, stack2.shape])
>>> array([[5, 3, 4],
       [3, 5, 4],
       [3, 4, 5]])


3. split
temp = np.arange(5)
np.split(temp,1)

s0=np.split (before_split, 5, axis=0)

s1=np.split (before_split, 3, axis=1)

s2=np.split (before_split, 4, axis=2)
---------------------------------------------------------------
ARRAY SHAPE MANIPULATION
.reshape((3,8))
.ravel()
my_3_8_array.flat

---------------------------------------------------------------
REARRANGE ARRAY ELEMENTS
my_3_8_array

np.fliplr(my_3_8_array)

np.fliplr(my_2_3_4_array)

np.flipud(my_3_8_array)

np.flipud(my_2_3_4_array)

np.roll(my_start_array, 5)
np.roll(my_start_array, -5)
np.roll(my_2_3_4_array, 2)
np.roll(my_2_3_4_array, -2)

np.rot90(my_3_8_array)
np.rot90(my_3_8_array, k=-1)
---------------------------------------------------------------
TRANSPOSE LIKE OPERATIONS
1-Dimension, no change
2-Dimensions,
	exchange rows and columns (a[i,j] becomes a[j,i])
3-Dimensions or more,
	use 'axes' parameter
	np.transpose(my_2_3_4_array, axes=(0,2,1))
	np.transpose(my_2_3_4_array, axes=(2,1,0))



swapaxes
np.swapaxes(my_2_3_4_array, 1, 0)

rollaxis
np.rollaxis(my_2_3_4_array, 0, 2)

---------------------------------------------------------------
TILING ARRAYS
tile
from: http://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html#numpy.tile

Construct an array by repeating A the number of times given by reps.

If reps has length d, the result will have dimension of max(d, A.ndim).

If A.ndim < d, A is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote A to d-dimensions manually before calling this function.

If A.ndim > d, reps is promoted to A.ndim by pre-pending 1’s to it. Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as (1, 1, 2, 2).

np.tile(my_start_array, 3)
---------------------------------------------------------------
QUIZ
************************************************************************************************************
6. SHORT EXAMPLES
************************************************************************************************************
UNIVERSAL FUNCTIONS
---------------------------------------------------------------
PYTHAGOREAN TRIANGLES
---------------------------------------------------------------
LINEAR ALGEBRA
# more efficient for large matrices
from numpy.linalg import solve
solve(my_first_matrix, right_hand_side)

# Compute the eigenvalues and right eigenvectors
from numpy.linalg import eig
eig(my_first_matrix)


---------------------------------------------------------------
FINDING PATTERNS
---------------------------------------------------------------
STATISTICS
"Probability Distributions"
Continuous distributions
	Normal: norm
	Chi squared: chi2
	Student's T: t
	Uniform: uniform
Discrete distributions
	Poisson: poisson
	Binomial: binomial
---------------------------------------------------------------
BRAIN TEASERS
Create a 5x5 identity matrix with integer components
	my_matrix = np.asmatrix(np.eye(5, dtype='int'))

Create a 2d array with ones on the border and zeros inside the border
	my_bordered_array = np.ones((5,5))
	my_bordered_array[1:-1,1:-1] = 0
	my_bordered_array


Create an 8x8 checker board with alternating zeros and ones
	my_checker_board = np.zeros((8,8),dtype=int)
	my_checker_board[1::2,::2] = 1
	my_checker_board[::2,1::2] = 1
	print(my_checker_board)


Without sorting, replace largest element in random array with the value 1234
	vector_size = 12
	my_random_vector = np.random.random(vector_size)
	my_random_vector[my_random_vector.argmax()] = 1234

Make an array read-only (immutable)
	my_ordinary_array = np.array(np.arange(12))
	my_ordinary_array.flags.writeable = False
	my_ordinary_array[5] = 1234 >>>ValueError: assignment destination is read-only


Print enumerated values from a 3x3 NumPy array
	my_3_3_array = np.arange(9).reshape(3,3)
	for index, value in np.ndenumerate(my_3_3_array):
	    print(index, value)
>>> 	(0, 0) 0
		(0, 1) 1
		(0, 2) 2
		(1, 0) 3
		(1, 1) 4
		(1, 2) 5
		(2, 0) 6
		(2, 1) 7
		(2, 2) 8	    

		
---------------------------------------------------------------
QUIZ
************************************************************************************************************
7. EXTENDED EXAMPLES
************************************************************************************************************
MAGIC SQUARES AND NUMPY
---------------------------------------------------------------
ADJACENCY MATRIX
---------------------------------------------------------------
MAGIC CHARACTERISTICS
---------------------------------------------------------------
BUILD MAGIC CUBES
---------------------------------------------------------------
QUIZ