INTRODUCTION
WELCOME (IN PROGRESS)
EXERCISE FILES
ABOUT PYTHON 3

1. INSTALLATION
INSTALLING PYTHON AND KOMODO ON A MAC
INSTALLING PYTHON AND KOMODO ON WINDOWS

2. LANGUAGE OVERVIEW
ABOUT THE OVERVIEW
HELLO WORLD
PYTHON ANATOMY
EXPRESSIONS AND STATEMENTS
WHITESPACE AND COMMENTS
USING PRINT()
BLOCKS AND SCOPE
CONDITIONALS
LOOPS
FUNCTIONS
OBJECTS

3. TYPES AND VALUES
OVERVIEW
THE STRING TYPE
NUMERIC TYPES
THE BOOL TYPE
SEQUENCE TYPES
TYPE() AND ID()

4. CONDITIONALS
CONDITIONAL SYNTAX
CONDITIONAL OPERATORS
CONDITIONAL ASSIGNMENT

5. OPERATORS
ARITHMETIC OPERATORS
BITWISE OPERATORS
COMPARISON OPERATORS
BOOLEAN OPERATORS
OPERATOR PRECEDENCE

6. LOOPS
PYTHON LOOPS
THE WHILE LOOP
THE FOR LOOP
ADDITIONAL CONTROLS

7. FUNCTIONS
DEFINING A FUNCTION
FUNCTION ARGUMENTS
8M 36S
SAVE FUNCTION ARGUMENTS
ARGUMENT LISTS
KEYWORD ARGUMENTS
RETURN VALUES
GENERATORS
DECORATORS

8. STRUCTURED DATA
BASIC DATA STRUCTURES
LISTS AND TUPLES
DICTIONARIES
SETS
LIST COMPREHENSION
MIXED STRUCTURES

9. CLASSES
CREATING A CLASS
CONSTRUCTING AN OBJECT
CLASS METHODS
OBJECT DATA
INHERITANCE
ITERATOR OBJECTS

10. EXCEPTIONS
HANDLING EXCEPTIONS
REPORTING ERRORS

11. STRING OBJECTS
OVERVIEW OF STRING OBJECTS
COMMON STRING METHODS
4M 15S
FORMATTING STRINGS
SPLITTING AND JOINING

12. FILE I/O
OPENING FILES
TEXT VS. BINARY MODE
TEXT FILES
BINARY FILES

13. BUILT-IN FUNCTIONS
NUMERIC FUNCTIONS
STRING FUNCTIONS
CONTAINER FUNCTIONS
OBJECT AND CLASS FUNCTIONS

14. MODULES
USING STANDARD MODULES
CREATING A MODULE

15. DATABASES
PYTHON DATABASE API
A DATABASE INTERFACE
EXAMPLE: SHORT URL DATABASE

CONCLUSION



INTRODUCTION
WELCOME (IN PROGRESS)
EXERCISE FILES
ABOUT PYTHON 3
There`s a core philosophy behind the Python language, which includes the following statements: 
	Beautiful is better than ugly. It`s always a good idea to make your code elegant and readable. 
	Explicit is better than implicit. Don`t make your readers guess what your code does, make it obvious. 
	Simple is better than complex. If you can make it simple, do. 
	Complex is better than complicated. If complexity is necessary, don`t complicate it. 
	Readability counts. As a casual reader with a good understanding of the Python language, you should be able to understand the code with a minimal amount of effort.
For complete LIST 
import this
>>>
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren`t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you`re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it`s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let`s do more of those!
----------------------------------------------------------------------------------------------------------------------
1. INSTALLATION
----------------------------------------------------------------------------------------------------------------------
INSTALLING PYTHON AND KOMODO ON A MAC
INSTALLING PYTHON AND KOMODO ON WINDOWS

----------------------------------------------------------------------------------------------------------------------
2. LANGUAGE OVERVIEW
----------------------------------------------------------------------------------------------------------------------
ABOUT THE OVERVIEW
HELLO WORLD

PYTHON ANATOMY
#!/usr/bin/env python3

EXPRESSIONS AND STATEMENTS
Generally speaking, a statement is a unit of execution, and an expression is a unit of evaluation. 
WHITESPACE AND COMMENTS
USING PRINT()
s="World"
#python 2
"HEllo %s"%s
#python 3 - string is a object in python3 so
"HEllo {}".format(s)
#after 3.6 
f"HEllo {s}"


BLOCKS AND SCOPE
CONDITIONALS
LOOPS
# simple fibonacci series
# the sum of two elements defines the next set

a, b = 0, 1
while b < 1000:
    print(b, end = ' ', flush = True)
    a, b = b, a + b

print() # line ending

FUNCTIONS
def isprime(n):
    if n <= 1:
        return False
    for x in range(2, n):
        if n % x == 0:
            return False
    else:
        return True
def listOfPrimes(n):
    for i in range(n):
        if isprime(i):
            print(i, end=' ')
n = 29
if isprime(n):
    print(f'{n} is prime')
else:
    print(f'{n} not prime')

listOfPrimes(100)

OBJECTS

class Duck:
    sound = 'Quaccckkk'
    walking = 'Walks Like a duck'
    def quack(self):
        print(self.sound)

    def walk(self):
        print(self.walking)

def main():
    donald = Duck()
    donald.quack()
    donald.walk()

if __name__ == '__main__': main()

----------------------------------------------------------------------------------------------------------------------
3. TYPES AND VALUES
----------------------------------------------------------------------------------------------------------------------
OVERVIEW
THE STRING TYPE
a=8
b=9
print(f"x is {a:<010} and  {b:>010}")
>>>x is 8000000000 and  0000000009


NUMERIC TYPES
integer floating
// / % 
x = .1+.1+.1-.3
>>> 5.551115123125783e-17 <class 'float'>
#should be 0.00

from decimal import *
a = Decimal('.10')
b = Decimal('.30')
x = a+a+a-b
print(x,type(x))
>>>
0.00 <class 'decimal.Decimal'>


print(x,type(x))
THE BOOL TYPE
x = False
print(x,type(x))
if x :
    print("True" )
else: 
    print("False" )
x = 0
print(x,type(x))
if x :
    print("True" )
else: 
    print("False" )
x = None
print(x,type(x))
if x :
    print("True" )
else: 
    print("False" )
    
x = ""
print(x,type(x))
if x :
    print("True" )
else: 
    print("False" )    
>>>
False <class 'bool'>
False
0 <class 'int'>
False
None <class 'NoneType'>
False
 <class 'str'>
False


SEQUENCE TYPES
List mutable
Tuple Immutable
range() Immutable
dict mutable


TYPE() AND ID()
a = (1, "Two", {"Three":3})
b = (1, "Two", {"Three":3})
print(a is b)
print(a[0] is b[0])
>>>
False
True


print(isinstance(a,tuple))
print(isinstance(a,list))
>>>
True
False
----------------------------------------------------------------------------------------------------------------------
4. CONDITIONALS
----------------------------------------------------------------------------------------------------------------------
CONDITIONAL SYNTAX
if True:
    print('if true')
elif False:
    print('elif true')
else:
    print('neither true')

CONDITIONAL OPERATORS
Comparision operators == ! <=>= == 
Identity operators is, is not
Membership operators in, not in

CONDITIONAL ASSIGNMENT
#Ternary
hungry = True
x = 'Feed the bear now!' if hungry else 'Do not feed the bear.'

----------------------------------------------------------------------------------------------------------------------
5. OPERATORS
----------------------------------------------------------------------------------------------------------------------
ARITHMETIC OPERATORS
+ - * / // % **  -- ++
BITWISE OPERATORS
& | ^ << >>
COMPARISON OPERATORS
< > <= >= == !=
BOOLEAN OPERATORS
and or not,in, not in, is, not is
OPERATOR PRECEDENCE
Paranthesis.
Exponent,unary , MDR,AS, Bitwise Shifts, Bitwise AND,Bitwise OR, Bitwise XOR, Bitwise OR, Comparision including membership tests and identity tests, Boolean NOT, Boolean AND, Boolean OR
----------------------------------------------------------------------------------------------------------------------
6. LOOPS
----------------------------------------------------------------------------------------------------------------------
PYTHON LOOPS
THE WHILE LOOP
secret = 'swordfish'
pw = ''

while pw != secret:
    pw = input("What's the secret word? ")

THE FOR LOOP
animals = ( 'bear', 'bunny', 'dog', 'cat', 'velociraptor' )

for pet in animals:
    print(pet)

ADDITIONAL CONTROLS
continue, break, else
----------------------------------------------------------------------------------------------------------------------
7. FUNCTIONS
----------------------------------------------------------------------------------------------------------------------
DEFINING A FUNCTION
def main():
    kitten()

def kitten():
    print('Meow.')

if __name__ == '__main__': main()
#All functions Returns None

FUNCTION ARGUMENTS
def kitten(*args):
    if len(args):
        for s in args:
            print(s)
    else: print('Meow.')
kitten('meow', 'grrr', 'purr') 
y = ('meow', 'grrr', 'purr') 
kitten(*y) 
#arguments with Defaults should be in the end
def puppy(a,b=2,c=True):
    if c:
        print('a+b = ',a+b)
    else: print('Meow.')
puppy(10)
puppy(10,c=True)
puppy(10,3)


https://www.linkedin.com/learning/python-essential-training-2/function-arguments

ARGUMENT LISTS
def kitten(*args):
    if len(args):
        for s in args:
            print(s)
    else: print('Meow.')
kitten('meow', 'grrr', 'purr') 
y = ('meow', 'grrr', 'purr') 
kitten(*y) 



KEYWORD ARGUMENTS
def kitten(**kwargs):
    if len(kwargs):
        for k in kwargs:
            print('Kitten {} says {}'.format(k, kwargs[k]))
    else: print('Meow.')

kitten(Buffy = 'meow', Zilla = 'grr', Angel = 'rawr')
d = dict(Buffy = 'meow', Zilla = 'grr', Angel = 'rawr')
kitten(**d)


RETURN VALUES
No difference between functions and procedures, all functions returns values. (None by default)

GENERATORS
Functions that serves as an iterator.
It returns a stream of values
example: range()

DECORATORS
Funtions that return a wrapper function
import time

def elapsed_time(f):
    def wrapper():
        t1 = time.time()
        f()
        t2 = time.time()
        print(f'Elapsed time: {(t2 - t1) * 1000} ms')
    return wrapper


@elapsed_time
def big_sum():
    num_list = []
    for num in (range(0, 10000)):
        num_list.append(num)
    print(f'Big sum: {sum(num_list)}')

def main():
    big_sum()

if __name__ == '__main__': main()
"https://www.linkedin.com/learning/python-essential-training-2/decorators"

Decorators are basically a wrapping/decoration around a funtion. So whenever we call that function, it`s decorator function is called instead wherein the call function is passed as the parameter to the decorator function. Uses are like the above function it decorates the time taken around the function call. in the Process the original definition is lost. So the above function will always print the time along with it.
----------------------------------------------------------------------------------------------------------------------
8. STRUCTURED DATA
----------------------------------------------------------------------------------------------------------------------
BASIC DATA STRUCTURES
List-[], Tuples-(), Dict-{}, Set-{}, 


LISTS AND TUPLES
Cannot apend in tuples-  Immutable
DICTIONARIES
animals = { 'kitten': 'meow', 'puppy': 'ruff!', 'lion': 'grrr',
        'giraffe': 'I am a giraffe!', 'dragon': 'rawr' }
OR
animals = dict( kitten= 'meow', puppy= 'ruff!', lion='grrr',
        giraffe= 'I am a giraffe!', dragon='rawr')

for k,v in animals:
	print("{k} : {v}")
>>>
kitten: meow
puppy: ruff!
lion: grrr
giraffe: I am a giraffe!
dragon: rawr



SETS
Sets is List "without duplicate unordered elements"

b = set("I`m sorry, Dave. I`m afraid I can`t do that.")
b
>>>
dc`ra efyDtvo.nIhsm,i

LIST/DICT COMPREHENSION
seq = range(11)
seq2 = [x * 2 for x in seq]
seq3 = [x for x in seq if x % 3 != 0]
seq4 = [(x,x * 2) for x in seq]

seq5 = {x : x * 2 for x in seq}

MIXED STRUCTURES

----------------------------------------------------------------------------------------------------------------------
9. CLASSES
----------------------------------------------------------------------------------------------------------------------
CREATING A CLASS
CONSTRUCTING AN OBJECT
def __init__(self, **kwargs):
        self._type = kwargs['type'] if 'type' in kwargs else 'kitten'
        self._name = kwargs['name'] if 'name' in kwargs else 'fluffy'
        self._sound = kwargs['sound'] if 'sound' in kwargs else 'meow'

CLASS METHODS
Getters and setters

def type(self, t = None):
        if t: self._type = t
        return self._type

def name(self, n = None):
        if n: self._name = n
        return self._name

def sound(self, s = None):
        if s: self._sound = s
        return self._sound



# toString() i java
 def __str__(self):
        return f'The {self.type()} is named "{self.name()}" and says "{self.sound()}".'



OBJECT DATA
"https://www.linkedin.com/learning/python-essential-training-2/object-data"
There are no private variables in Python instead we have a convention to use _ before a variable say _name.
And it is uggested not to use these variables outside the class. 
These are Object variables and not class variables.
If you cahnge the values of these variables using an object then only that object`s variable value wil be updated and won`t reflect on other instance of class.


INHERITANCE

super()


class Animal:
    def __init__(self, **kwargs):
        if 'type' in kwargs: self._type = kwargs['type']
        if 'name' in kwargs: self._name = kwargs['name']
        if 'sound' in kwargs: self._sound = kwargs['sound']

    def type(self, t = None):
        if t: self._type = t
        try: return self._type
        except AttributeError: return None

    def name(self, n = None):
        if n: self._name = n
        try: return self._name
        except AttributeError: return None

    def sound(self, s = None):
        if s: self._sound = s
        try: return self._sound
        except AttributeError: return None

class Duck(Animal):
    def __init__(self, **kwargs):
        self._type = 'duck'
        if 'type' in kwargs: del kwargs['type']
        super().__init__(**kwargs)

class Kitten(Animal):
    def __init__(self, **kwargs):
        self._type = 'kitten'
        if 'type' in kwargs: del kwargs['type']
        super().__init__(**kwargs)

def print_animal(o):
    if not isinstance(o, Animal):
        raise TypeError('print_animal(): requires an Animal')
    print(f'The {o.type()} is named "{o.name()}" and says "{o.sound()}".')

def main():
    a0 = Kitten(name = 'fluffy', sound = 'rwar')
    a1 = Duck(name = 'donald', sound = 'quack')
    print_animal(a0)
    print_animal(a1)


ITERATOR OBJECTS

----------------------------------------------------------------------------------------------------------------------
10. EXCEPTIONS
----------------------------------------------------------------------------------------------------------------------
HANDLING EXCEPTIONS
try:
	x= 5/0
except ValueError:
	print("I caught VE")
except:
	print("unknown Error {sys.exc_info()}")
else: #If no error
	print(x)

REPORTING ERRORS
	if numargs < 1:
        raise TypeError(f'expected at least 1 argument, got {numargs}')
    elif numargs == 1:
        stop = args[0]
    elif numargs == 2:
        (start, stop) = args
    elif numargs == 3:
        (start, stop, step) = args
    else: raise TypeError(f'expected at most 3 arguments, got {numargs}')


def inclusive_range(*args):
    numargs = len(args)
    start = 0
    step = 1
    
    # initialize parameters
    if numargs < 1:
        raise TypeError(f'expected at least 1 argument, got {numargs}')
    elif numargs == 1:
        stop = args[0]
    elif numargs == 2:
        (start, stop) = args
    elif numargs == 3:
        (start, stop, step) = args
    else: raise TypeError(f'expected at most 3 arguments, got {numargs}')

    # generator
    i = start
    while i <= stop:
        yield i
        i += step

def main():
    try:
        for i in inclusive_range(1,4,5,2):
            print(i, end = ' ', flush = True)
    except TypeError as e:
        print(f"Range Error : {e}") #Range Error : expected at most 3 arguments, got 4



----------------------------------------------------------------------------------------------------------------------
11. STRING OBJECTS
----------------------------------------------------------------------------------------------------------------------
OVERVIEW OF STRING OBJECTS
String are OBJECTS
They are Immutable
# Subclassing the String
# Making the __str__ return Reverse of the string
class MyString(str)
	def __str__(self):
		return self[::-1]

COMMON STRING METHODS
upper() lower() capitalize() title() swapcase() casefold()

FORMATTING STRINGS

print('Hello, World.')
x = "World"
y = "Morning"
print("Hello {}".format(x))
print("Hello {} {}".format(x,y))
print("Hello {a} {b}".format(a=x,b=y))
print("Hello {a} {b}  {a}  {a}".format(a=x,b=y))# >>> Hello World Morning  World  World
print("Hello {0:<20} {1:>20}".format(x,y))



print("{:,}".format(10000000000)) #10,000,000,000
print("{:_}".format(10000000000)) #10_000_000_000


print("{:f}".format(1231.8345812312)) #default 6  # 1231.834581
print("{:.3f}".format(1231.8345812312)) # 1231.835


print("{:d}".format(14))#14
print("{:f}".format(14))#14.000000
print("{:b}".format(14))#1110
print("{:o}".format(14))#16
print("{:X}".format(14))#E

using f-string
print(f"{14:d}")#14
print(f"{14:f}")#14.000000
print(f"{14:b}")#1110
print(f"{14:o}")#16
print(f"{14:X}")#E


SPLITTING AND JOINING
s = 'This is a long string with a bunch of words in it.'
print(s.split())
#['This', 'is', 'a', 'long', 'string', 'with', 'a', 'bunch', 'of', 'words', 'in', 'it.']

print(s.split('a'))
#['This is ', ' long string with ', ' bunch of words in it.']

#Join takes in list argument and joints the list with the string character on which join is called
print("_".join(s.split('a')))
#This is _ long string with _ bunch of words in it.



----------------------------------------------------------------------------------------------------------------------
12. FILE I/O
----------------------------------------------------------------------------------------------------------------------
OPENING FILES
def main():
    f = open('lines.txt','r')
    for line in f:
        print(line.rstrip())

if __name__ == '__main__': main()

'r' - default
'w' - writes into file, empties if not. If file doesn`t exists it creates it.
'a' - Doesn`t empty or create the file
r+ w+ a+ to add more than 1 rights
r+b or r+t for binary and text(default) modes 


TEXT VS. BINARY MODE


TEXT FILES

def main():
    infile = open('lines.txt', 'rt')
    outfile = open('lines-copy.txt', 'wt')
    for line in infile:
        #print(line.rstrip(), file=outfile)
        # OR 
        outfile.writelines(line)
        print('.', end='', flush=True)
    outfile.close()
    print('\ndone.')


Write into a file
print(line.rstrip(), file=outfile)
        # OR 
outfile.writelines(line)

BINARY FILES
Creating a copy of an image file
def main():
    infile = open('berlin.jpg', 'rb')
    outfile = open('berlin-copy.jpg', 'wb')
    while True:
        buf = infile.read(10240)
        if buf:
            outfile.write(buf)
            print('.', end='', flush=True)
        else: break
    outfile.close()
    print('\ndone.')
----------------------------------------------------------------------------------------------------------------------
13. BUILT-IN FUNCTIONS
----------------------------------------------------------------------------------------------------------------------
NUMERIC FUNCTIONS
int()
abs()
divmod(15,6) #(2, 3)

y = 57 + 23j #(57+23j)
#OR
y = complex(57, 23) #(57+23j)

STRING FUNCTIONS
__repr__()
ascii()
chr()
ord()


CONTAINER FUNCTIONS
reversed()
sum()
max()
min()
any()
all()
zip() # zip 2 list together
enumerate() # To get an Index : Value pair out of a tuple

OBJECT AND CLASS FUNCTIONS
type()
isinstance()
id()



----------------------------------------------------------------------------------------------------------------------
14. MODULES
----------------------------------------------------------------------------------------------------------------------
USING STANDARD MODULES
import sys,os,random,datetime,calender,


CREATING A MODULE
saytime
#local time is half past six


----------------------------------------------------------------------------------------------------------------------
15. DATABASES
----------------------------------------------------------------------------------------------------------------------
PYTHON DATABASE API
A DATABASE INTERFACE
EXAMPLE: SHORT URL DATABASE

----------------------------------------------------------------------------------------------------------------------
CONCLUSION
----------------------------------------------------------------------------------------------------------------------
